using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Iviz.Msgs;

namespace Iviz.Roslib
{
    public class RosPublisher
    {
        readonly TcpSenderManager manager;
        readonly ConcurrentDictionary<string, object> ids = new ConcurrentDictionary<string, object>();
        readonly RosClient client;
        readonly Type topicClassType;
        int totalPublishers;

        /// <summary>
        /// Whether this publisher is valid.
        /// </summary>
        bool IsAlive { get; set; }
        /// <summary>
        /// The name of the topic.
        /// </summary>
        public string Topic => manager.Topic;
        /// <summary>
        /// The ROS message type of the topic.
        /// </summary>
        public string TopicType => manager.TopicType;
        /// <summary>
        /// The number of publishers in the topic.
        /// </summary>
        public int NumSubscribers => manager.NumConnections;
        /// <summary>
        /// The number of ids generated by this publisher.
        /// </summary>
        public int NumIds => ids.Count;

        /// <summary>
        /// Whether latching is enabled. When active, new subscribers will automatically receive a copy of the last message sent.
        /// </summary>
        public bool LatchingEnabled
        {
            get => manager.Latching;
            set => manager.Latching = value;
        }

        /// <summary>
        /// The queue size in bytes.
        /// If a message arrives that makes the queue larger than this, the oldest message will be discarded.
        /// </summary>
        public int MaxQueueSizeInBytes
        {
            get => manager.MaxQueueSizeInBytes;
            set => manager.MaxQueueSizeInBytes = value;
        }

        /// <summary>
        /// Timeout in milliseconds to wait for a subscriber handshake.
        /// </summary>        
        public int TimeoutInMs
        {
            get => manager.TimeoutInMs;
            set => manager.TimeoutInMs = value;
        }

        /// <summary>
        /// Called when the number of subscribers has changed.
        /// </summary>        
        public event Action<RosPublisher> NumSubscribersChanged;

        internal RosPublisher(RosClient client, TcpSenderManager manager, Type topicClassType)
        {
            this.client = client;
            this.manager = manager;
            this.topicClassType = topicClassType;
            IsAlive = true;

            manager.NumConnectionsChanged += () => NumSubscribersChanged?.Invoke(this);
        }

        void AssertIsAlive()
        {
            if (!IsAlive)
            {
                throw new ObjectDisposedException("This is not a valid publisher");
            }
        }

        string GenerateId()
        {
            string newId = totalPublishers == 0 ? Topic : $"{Topic}-{totalPublishers}";
            totalPublishers++;
            return newId;
        }
        
        /// <summary>
        /// Returns a structure that represents the internal state of the publisher. 
        /// </summary>        
        public PublisherTopicState GetState()
        {
            AssertIsAlive();
            return new PublisherTopicState(Topic, TopicType, ids.Keys.ToArray(), manager.GetStates());
        }

        
        /// <summary>
        /// Publishes the given message into the topic. 
        /// </summary>
        /// <param name="message">The message to be published.</param>
        /// <exception cref="ArgumentNullException">The message is null</exception>
        /// <exception cref="InvalidMessageTypeException">The message type does not match.</exception>        
        public void Publish(IMessage message)
        {
            if (message is null)
            {
                throw new ArgumentNullException(nameof(message));
            }

            if (!MessageTypeMatches(message.GetType())) 
            {
                throw new InvalidMessageTypeException("Type does not match publisher.");
            }

            message.RosValidate();
            AssertIsAlive();
            manager.Publish(message);
        }

        internal (string hostname, int port) RequestTopicRpc(string remoteCallerId)
        {
            IPEndPoint endPoint = manager.CreateConnectionRpc(remoteCallerId);
            return (manager.CallerUri.Host, endPoint.Port);
        }

        internal void Stop()
        {
            ids.Clear();
            manager.Stop();
            NumSubscribersChanged = null;
            IsAlive = false;
        }

        
        /// <summary>
        /// Generates a new advertisement id. Use this string for Unadvertise().
        /// </summary>
        /// <returns>The advertisement id.</returns>        
        public string Advertise()
        {
            AssertIsAlive();

            string id = GenerateId();
            ids.TryAdd(id, null);

#if DEBUG__
            Logger.LogDebug($"{this}: Advertising '{Topic}' with type {TopicType} and id '{id}'");
#endif

            return id;
        }

        bool RemoveId(string topicId)
        {
            if (topicId is null) { throw new ArgumentNullException(nameof(topicId)); }
            return ids.TryRemove(topicId, out _);
        }
        
        /// <summary>
        /// Unregisters the given id from the publisher. If the publisher has no ids left, the topic will be unadvertised from the master.
        /// </summary>
        /// <param name="id">The id to be unregistered.</param>
        /// <returns>Whether the id belonged to the publisher.</returns>
        public bool Unadvertise(string id)
        {
            bool removed = RemoveId(id);

            if (ids.Count == 0)
            {
                Stop();
                client.RemovePublisher(this);
            }

            return removed;
        }
        
        /// <summary>
        /// Unregisters the given id from the publisher. If the publisher has no ids left, the topic will be unadvertised from the master.
        /// </summary>
        /// <param name="id">The id to be unregistered.</param>
        /// <returns>Whether the id belonged to the publisher.</returns>
        public async Task<bool> UnadvertiseAsync(string id)
        {
            bool removed = RemoveId(id);

            if (ids.Count == 0)
            {
                Stop();
                await client.RemovePublisherAsync(this);
            }

            return removed;
        }        

        /// <summary>
        /// Checks whether this publisher has provided the given id from an Advertise() call.
        /// </summary>
        /// <param name="id">Identifier to check.</param>
        /// <returns>Whether the id was provided by this publisher.</returns>        
        public bool ContainsId(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            return ids.ContainsKey(id);
        }
        
        /// <summary>
        /// Checks whether the class of the publisher message type corresponds to the given type
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>Whether the class type matches.</returns>
        public bool MessageTypeMatches(Type type)
        {
            return type == topicClassType;
        }        
        
        /// <summary>
        /// Checks whether the class of the subscriber message type corresponds to the given type.
        /// </summary>
        /// <typeparam name="T">The type to check.</typeparam>
        /// <returns>Whether the class type matches.</returns>
        public bool MessageTypeMatches<T>()
        {
            return MessageTypeMatches(typeof(T));
        }        
        
        public override string ToString()
        {
            return $"[Publisher {Topic} [{TopicType}] ]";
        }        
    }
}