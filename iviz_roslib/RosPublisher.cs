using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Iviz.Msgs;
using Iviz.Roslib.XmlRpc;
using Iviz.Tools;

namespace Iviz.Roslib;

/// <summary>
///     Manager for a ROS publisher.
/// </summary>
/// <typeparam name="TMessage">Topic type</typeparam>
public sealed class RosPublisher<TMessage> : BaseRosPublisher<TMessage>, IRos1Publisher where TMessage : IMessage
{
    readonly RosClient client;
    readonly List<string> ids = new();
    readonly SenderManager<TMessage> manager;
    readonly Serializer<TMessage> serializer;
    int totalPublishers;
    bool disposed;

    /// <summary>
    ///     The number of ids generated by this publisher.
    /// </summary>
    public int NumIds => ids.Count;

    /// <summary>
    ///     The queue size in bytes.
    ///     If a message arrives that makes the queue larger than this, the oldest message will be discarded.
    /// </summary>
    public int MaxQueueSizeInBytes
    {
        get => manager.MaxQueueSizeInBytes;
        set => manager.MaxQueueSizeInBytes = value;
    }

    public override int NumSubscribers => manager.NumConnections;

    public int TimeoutInMs
    {
        get => manager.TimeoutInMs;
        set => manager.TimeoutInMs = value;
    }

    public bool ForceTcpNoDelay
    {
        get => manager.ForceTcpNoDelay;
        set => manager.ForceTcpNoDelay = value;
    }

    public bool LatchingEnabled
    {
        get => manager.LatchingEnabled;
        set => manager.LatchingEnabled = value;
    }

    /// <summary>
    /// Manually sets the latched message.
    /// </summary>
    public TMessage LatchedMessage
    {
        set => manager.LatchedMessage = value;
    }

    /// <summary>
    ///     Called when the number of subscribers has changed.
    /// </summary>
    public event Action<RosPublisher<TMessage>>? NumSubscribersChanged;

    internal RosPublisher(RosClient client, TopicInfo topicInfo) : base(topicInfo.Topic, topicInfo.Type)
    {
        this.client = client;
        serializer = ((TMessage)topicInfo.Generator).CreateSerializer();
        manager = new SenderManager<TMessage>(this, topicInfo) { ForceTcpNoDelay = true };
    }

    string GenerateId()
    {
        int currentCount = Interlocked.Increment(ref totalPublishers);
        int lastId = currentCount - 1;
        return lastId == 0 ? Topic : $"{Topic}-{lastId.ToString()}";
    }

    bool RemoveId(string topicId)
    {
        return ids.Remove(topicId);
    }

    public override bool ContainsId(string id)
    {
        if (id is null) BuiltIns.ThrowArgumentNull(nameof(id));
        return ids.Contains(id);
    }

    TopicRequestRpcResult IRos1Publisher.RequestTopicRpc(bool requestsTcp, RpcUdpTopicRequest? requestsUdp,
        out Endpoint? tcpResponse, out RpcUdpTopicResponse? udpResponse)
    {
        if (disposed)
        {
            tcpResponse = null;
            udpResponse = null;
            return TopicRequestRpcResult.Disposing;
        }

        if (requestsTcp)
        {
            tcpResponse = new Endpoint(client.CallerUri.Host, manager.Endpoint.Port);
            udpResponse = null;
            return TopicRequestRpcResult.Success;
        }

        if (requestsUdp == null)
        {
            throw new InvalidOperationException("Either UDP or TCP needs to be requested");
        }

        tcpResponse = null;
        udpResponse = manager.CreateUdpConnection(requestsUdp, client.CallerUri.Host);
        return TopicRequestRpcResult.Success;
    }

    internal void RaiseNumSubscribersChanged()
    {
        if (NumSubscribersChanged == null)
        {
            return;
        }

        Task.Run(() =>
        {
            try
            {
                NumSubscribersChanged?.Invoke(this);
            }
            catch (Exception e)
            {
                Logger.LogErrorFormat("{0}: Exception from NumSubscribersChanged : {1}", this, e);
            }
        }, default);
    }

    internal bool TryGetLoopbackReceiver(in Endpoint endpoint, out LoopbackReceiver<TMessage>? receiver)
    {
        return client.TryGetLoopbackReceiver(Topic, endpoint, out receiver);
    }

    /// <summary>
    ///     Publishes the given message into the topic.
    /// </summary>
    /// <param name="message">The message to be published.</param>
    /// <exception cref="ArgumentNullException">The message is null</exception>
    /// <exception cref="RosInvalidMessageTypeException">The message type does not match.</exception>
    public override void Publish(in TMessage message)
    {
        AssertIsAlive();
        serializer.RosValidate(message);
        manager.Publish(message);
    }

    public override ValueTask PublishAsync(in TMessage message, RosPublishPolicy policy = RosPublishPolicy.DoNotWait,
        CancellationToken token = default)
    {
        AssertIsAlive();
        serializer.RosValidate(message);

        if (policy == RosPublishPolicy.DoNotWait)
        {
            manager.Publish(message);
            return default;
        }

        if (policy == RosPublishPolicy.WaitUntilSent)
        {
            return manager.PublishAndWaitAsync(message, token);
        }

        return default;
    }

    public override string Advertise()
    {
        AssertIsAlive();

        string id = GenerateId();
        ids.Add(id);
        return id;
    }

    public override bool Unadvertise(string id, CancellationToken token = default)
    {
        if (!IsAlive) return true;

        bool removed = RemoveId(id ?? throw new ArgumentNullException(nameof(id)));

        if (ids.Count == 0)
        {
            TaskUtils.RunSync(RemovePublisherAsync, token);
        }

        return removed;
    }

    public override async ValueTask<bool> UnadvertiseAsync(string id, CancellationToken token = default)
    {
        if (!IsAlive) return true;

        bool removed = RemoveId(id ?? throw new ArgumentNullException(nameof(id)));

        {
            await RemovePublisherAsync(token);
        }

        return removed;
    }

    Task RemovePublisherAsync(CancellationToken token)
    {
        var disposeTask = DisposeAsync(token).AwaitNoThrow(this);
        var unadvertiseTask = client.RemovePublisherAsync(this, token).AwaitNoThrow(this);
        return Task.WhenAll(disposeTask, unadvertiseTask);
    }

    public void UnsetLatch()
    {
        manager.UnsetLatch();
    }

    public override PublisherState GetState()
    {
        AssertIsAlive();
        return new PublisherState(Topic, TopicType, ids, manager.GetStates());
    }

    public override ValueTask<PublisherState> GetStateAsync(CancellationToken token = default) => new(GetState());

    public override async ValueTask DisposeAsync(CancellationToken token)
    {
        if (disposed) return;
        disposed = true;

        runningTs.Cancel();
        ids.Clear();

        await manager.DisposeAsync(token).AwaitNoThrow(this);

        NumSubscribersChanged = null;
    }

    public override void Dispose()
    {
        if (disposed) return;
        disposed = true;

        runningTs.Cancel();
        ids.Clear();
        manager.Dispose();
        NumSubscribersChanged = null;
    }


    public override string ToString()
    {
        return $"[{nameof(RosPublisher<TMessage>)} {Topic} [{TopicType}] ]";
    }
}