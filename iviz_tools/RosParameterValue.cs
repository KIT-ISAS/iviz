using System;
using System.Runtime.CompilerServices;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Iviz.Tools;

/// <summary>
/// Contains an arbitrary object/value generated by an XML-RPC function.
/// </summary>
public readonly struct RosParameterValue
{
    public enum Type
    {
        Empty,
        Integer,
        Double,
        Boolean,
        DateTime,
        String,
        Array,
        Base64,
        Struct
    }

    readonly long l;
    readonly object? o;
    readonly Type type;

    public Type ValueType => type;
    public bool IsEmpty => type == Type.Empty;

    public RosParameterValue(double d)
    {
        o = null;
        l = ToLong(d);
        type = Type.Double;
    }

    public RosParameterValue(bool b)
    {
        o = null;
        l = b ? 1 : 0;
        type = Type.Boolean;
    }

    public RosParameterValue(int i)
    {
        o = null;
        l = i;
        type = Type.Integer;
    }

    public RosParameterValue(string s)
    {
        l = 0;
        o = s;
        type = Type.String;
    }

    public RosParameterValue(DateTime dt)
    {
        l = dt.Ticks;
        o = null;
        type = Type.DateTime;
    }

    public RosParameterValue(byte[] bs)
    {
        l = 0;
        o = bs;
        type = Type.Base64;
    }

    public RosParameterValue(RosParameterValue[] os)
    {
        l = 0;
        o = os;
        type = Type.Array;
    }

    public RosParameterValue((string Key, RosParameterValue Value)[] vs)
    {
        l = 0;
        o = vs;
        type = Type.Struct;
    }

    public bool TryGetBoolean(out bool value)
    {
        if (type == Type.Boolean)
        {
            value = (l != 0);
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetDouble(out double value)
    {
        if (type == Type.Double)
        {
            value = ToDouble(l);
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetInteger(out int value)
    {
        if (type == Type.Integer)
        {
            value = (int)l;
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetString(out string value)
    {
        if (type == Type.String)
        {
            value = (string)o!;
            return true;
        }

        value = "";
        return false;
    }

    public bool TryGetDateTime(out DateTime value)
    {
        if (type == Type.DateTime)
        {
            value = new DateTime(l);
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetBase64(out byte[] value)
    {
        if (type == Type.Base64)
        {
            value = (byte[])o!;
            return true;
        }

        value = Array.Empty<byte>();
        return false;
    }

    public bool TryGetArray(out RosParameterValue[] value)
    {
        if (type == Type.Array)
        {
            value = (RosParameterValue[])o!;
            return true;
        }

        value = Array.Empty<RosParameterValue>();
        return false;
    }

    public bool TryGetStruct(out (string Key, RosParameterValue Value)[] value)
    {
        if (type == Type.Struct)
        {
            value = ((string, RosParameterValue)[])o!;
            return true;
        }

        value = Array.Empty<(string, RosParameterValue)>();
        return false;
    }

    public override string ToString() => type switch
    {
        Type.Integer => $"[int:{((int)l).ToString()}]",
        Type.Empty => "[empty]",
        Type.Double => $"[double:{ToDouble(l).ToString(Defaults.Culture)}]",
        Type.Boolean => l != 0 ? "[bool:true]" : "[bool:false]",
        Type.DateTime => $"[datetime:{new DateTime(l).ToString(Defaults.Culture)}]",
        Type.String => $"[string:{(string)o!}]",
        Type.Array => $"[array:{((Array)o!).Length.ToString()} elems]",
        Type.Base64 => $"[base64:{((Array)o!).Length.ToString()} bytes]",
        Type.Struct => $"[struct:{((Array)o!).Length.ToString()} fields]",
        _ => throw new ArgumentOutOfRangeException()
    };

    static double ToDouble(long l) => Unsafe.As<long, double>(ref l);
    
    static long ToLong(double d) => Unsafe.As<double, long>(ref d);

    public class JsonConverter : JsonConverter<RosParameterValue>
    {
        public int MaxStringLength { get; set; } = 10000;

        public override void WriteJson(JsonWriter writer, RosParameterValue value, JsonSerializer serializer)
        {
            switch (value.ValueType)
            {
                case Type.String:
                    value.TryGetString(out string str);
                    if (str.Length <= MaxStringLength)
                    {
                        writer.WriteValue(str);
                    }
                    else
                    {
                        writer.WriteValue(str[..MaxStringLength]);
                        writer.WriteComment("... + " + (str.Length - MaxStringLength) + " chars");
                    }

                    break;
                case Type.Integer:
                    value.TryGetInteger(out int i);
                    writer.WriteValue(i);
                    break;
                case Type.Double:
                    value.TryGetDouble(out double d);
                    writer.WriteValue(d);
                    break;
                case Type.Boolean:
                    value.TryGetBoolean(out bool b);
                    writer.WriteValue(b);
                    break;
                case Type.DateTime:
                    value.TryGetDateTime(out DateTime dt);
                    writer.WriteValue(dt.ToString("yyyy-MM-dd HH-mm-ss"));
                    break;
                case Type.Array:
                    value.TryGetArray(out RosParameterValue[] array);
                    var a = new JArray();
                    foreach (var innerValue in array)
                    {
                        a.Add(JToken.FromObject(innerValue, serializer));
                    }

                    a.WriteTo(writer);
                    break;
                case Type.Struct:
                    value.TryGetStruct(out (string Key, RosParameterValue Value)[] dict);
                    var o = new JObject();
                    foreach ((string key, RosParameterValue innerValue) in dict)
                    {
                        o.Add(new JProperty(key, JToken.FromObject(innerValue, serializer)));
                    }

                    o.WriteTo(writer);
                    break;
            }
        }

        public override RosParameterValue ReadJson(JsonReader reader, System.Type objectType,
            RosParameterValue existingValue,
            bool hasExistingValue, JsonSerializer serializer)
        {
            throw new NotImplementedException();
        }

        public override bool CanRead => false;
    }
}