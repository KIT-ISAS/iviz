using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Iviz.Tools;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Iviz.XmlRpc;

/// <summary>
/// Contains an arbitrary object/value generated by an XML-RPC function.
/// </summary>
public readonly struct XmlRpcValue
{
    public enum Type
    {
        Empty,
        Integer,
        Double,
        Boolean,
        DateTime,
        String,
        Array,
        Base64,
        Struct
    }

    readonly long l;
    readonly object? o;
    readonly Type type;

    public Type ValueType => type;
    public bool IsEmpty => type == Type.Empty;

    public XmlRpcValue(double d)
    {
        o = null;
        l = DoubleLongReinterpret.ToLong(d);
        type = Type.Double;
    }

    public XmlRpcValue(bool b)
    {
        o = null;
        l = b ? 1 : 0;
        type = Type.Boolean;
    }

    public XmlRpcValue(int i)
    {
        o = null;
        l = i;
        type = Type.Integer;
    }

    public XmlRpcValue(string s)
    {
        l = 0;
        o = s;
        type = Type.String;
    }

    public XmlRpcValue(DateTime dt)
    {
        l = dt.Ticks;
        o = null;
        type = Type.DateTime;
    }

    public XmlRpcValue(byte[] bs)
    {
        l = 0;
        o = bs;
        type = Type.Base64;
    }

    public XmlRpcValue(XmlRpcValue[] os)
    {
        l = 0;
        o = os;
        type = Type.Array;
    }

    public XmlRpcValue((string Key, XmlRpcValue Value)[] vs)
    {
        l = 0;
        o = vs;
        type = Type.Struct;
    }

    public bool TryGetBoolean(out bool value)
    {
        if (type == Type.Boolean)
        {
            value = (l != 0);
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetDouble(out double value)
    {
        if (type == Type.Double)
        {
            value = DoubleLongReinterpret.ToDouble(l);
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetInteger(out int value)
    {
        if (type == Type.Integer)
        {
            value = (int) l;
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetString(out string value)
    {
        if (type == Type.String)
        {
            value = (string) o!;
            return true;
        }

        value = "";
        return false;
    }

    public bool TryGetDateTime(out DateTime value)
    {
        if (type == Type.DateTime)
        {
            value = new DateTime(l);
            return true;
        }

        value = default;
        return false;
    }

    public bool TryGetBase64(out byte[] value)
    {
        if (type == Type.Base64)
        {
            value = (byte[]) o!;
            return true;
        }

        value = Array.Empty<byte>();
        return false;
    }

    public bool TryGetArray(out XmlRpcValue[] value)
    {
        if (type == Type.Array)
        {
            value = (XmlRpcValue[]) o!;
            return true;
        }

        value = Array.Empty<XmlRpcValue>();
        return false;
    }

    public bool TryGetStruct(out (string Key, XmlRpcValue Value)[] value)
    {
        if (type == Type.Struct)
        {
            value = ((string, XmlRpcValue)[]) o!;
            return true;
        }

        value = Array.Empty<(string, XmlRpcValue)>();
        return false;
    }

    public XmlRpcArg AsArg() => type switch
    {
        Type.Integer => (int) l,
        Type.Empty => throw new InvalidOperationException("Empty object"),
        Type.Double => DoubleLongReinterpret.ToDouble(l),
        Type.Boolean => l != 0,
        Type.DateTime => new DateTime(l),
        Type.String => (string) o!,
        Type.Array => ((XmlRpcValue[]) o!).Select(wrapper => wrapper.AsArg()).ToArray(),
        Type.Base64 => (byte[]) o!,
        Type.Struct => (((string Key, XmlRpcValue Value)[]) o!)
            .Select(entry => (entry.Key, entry.Value.AsArg())).ToArray(),
        _ => throw new ArgumentOutOfRangeException()
    };

    public override string ToString() => type switch
    {
        Type.Integer => $"[int:{((int) l).ToString()}]",
        Type.Empty => "[empty]",
        Type.Double => $"[double:{DoubleLongReinterpret.ToDouble(l).ToString(Defaults.Culture)}]",
        Type.Boolean => l != 0 ? "[bool:true]" : "[bool:false]",
        Type.DateTime => $"[datetime:{new DateTime(l).ToString(Defaults.Culture)}]",
        Type.String => $"[string:{(string) o!}]",
        Type.Array => $"[array:{((Array) o!).Length.ToString()} elems]",
        Type.Base64 => $"[base64:{((Array) o!).Length.ToString()} bytes]",
        Type.Struct => $"[struct:{((Array) o!).Length.ToString()} fields]",
        _ => throw new ArgumentOutOfRangeException()
    };

    static class DoubleLongReinterpret
    {
        public static double ToDouble(long l) => Unsafe.As<long, double>(ref l);
        public static long ToLong(double d) => Unsafe.As<double, long>(ref d);
    }

    public class JsonConverter : JsonConverter<XmlRpcValue>
    {
        public int MaxStringLength { get; set; } = 10000;

        public override void WriteJson(JsonWriter writer, XmlRpcValue value, JsonSerializer serializer)
        {
            switch (value.ValueType)
            {
                case Type.String:
                    value.TryGetString(out string str);
                    if (str.Length <= MaxStringLength)
                    {
                        writer.WriteValue(str);
                    }
                    else
                    {
                        writer.WriteValue(str[..MaxStringLength]);
                        writer.WriteComment("... + " + (str.Length - MaxStringLength) + " chars");
                    }
                    break;
                case Type.Integer:
                    value.TryGetInteger(out int i);
                    writer.WriteValue(i);
                    break;
                case Type.Double:
                    value.TryGetDouble(out double d);
                    writer.WriteValue(d);
                    break;
                case Type.Boolean:
                    value.TryGetBoolean(out bool b);
                    writer.WriteValue(b);
                    break;
                case Type.DateTime:
                    value.TryGetDateTime(out DateTime dt);
                    writer.WriteValue(dt.ToString("yyyy-MM-dd HH-mm-ss"));
                    break;
                case Type.Array:
                    value.TryGetArray(out XmlRpcValue[] array);
                    var a = new JArray();
                    foreach (var innerValue in array)
                    {
                        a.Add(JToken.FromObject(innerValue, serializer));
                    }

                    a.WriteTo(writer);
                    break;
                case Type.Struct:
                    value.TryGetStruct(out (string Key, XmlRpcValue Value)[] dict);
                    var o = new JObject();
                    foreach ((string key, XmlRpcValue innerValue) in dict)
                    {
                        o.Add(new JProperty(key, JToken.FromObject(innerValue, serializer)));
                    }

                    o.WriteTo(writer);
                    break;
            }
        }

        public override XmlRpcValue ReadJson(JsonReader reader, System.Type objectType, XmlRpcValue existingValue,
            bool hasExistingValue, JsonSerializer serializer)
        {
            throw new NotImplementedException();
        }

        public override bool CanRead => false;
    }
}